use convert_case::{Case, Casing};
use handlebars::Handlebars;
use log::{debug, info, warn};
use serde_json::{json, Value};
use std::fs;
use std::path::Path;

const DEFAULT_SCHEMA_PATH: &str = "./deriv-api-docs/config/v3/";
const API_CALLS_FILE: &str = "./src/api/calls.rs";
const SUBSCRIPTION_CALLS_FILE: &str = "./src/api/subscription_calls.rs";

// Templates for code generation
const HEADER_TEMPLATE: &str = r#"
// Code generated by generate_calls.rs, DO NOT EDIT.
use crate::client::DerivClient;
use crate::error::Result;
use deriv_api_schema::*;
use crate::subscription::Subscription;

impl DerivClient {
"#;

const API_CALL_TEMPLATE: &str = r#"
/// {{description}}
pub async fn {{fn_name}}(&self, request: deriv_api_schema::{{request_type}}) -> Result<deriv_api_schema::{{response_type}}> {
    self.send_request(&request).await
}
"#;

const SUBSCRIPTION_CALL_TEMPLATE: &str = r#"
/// Subscribe to {{description}}
pub async fn subscribe_{{fn_name}}(&self, request: deriv_api_schema::{{request_type}}) -> Result<(deriv_api_schema::{{response_type}}, Subscription<deriv_api_schema::{{stream_type}}>)> {
    let mut request = request;
    {{{subscribe_assignment}}} // Use placeholder for assignment
    let initial_response = self.send_request(&request).await?;
    // Subscription setup will be implemented here
    Ok(unimplemented!("Subscription not implemented yet"))
}
"#;

#[derive(Debug)]
struct ApiEndpoint {
    name: String,
    description: String,
    has_subscription: bool,
    request_type: String,
    response_type: String,
    stream_type: Option<String>,
    feature_name: String,
    subscribe_field_type: Option<String>,
    subscribe_field_required: bool,
}

#[derive(Debug)]
enum GeneratorError {
    Io(std::io::Error),
    Json(serde_json::Error),
    Template(handlebars::TemplateError),
    Render(handlebars::RenderError),
}

impl From<std::io::Error> for GeneratorError {
    fn from(err: std::io::Error) -> Self {
        GeneratorError::Io(err)
    }
}

impl From<serde_json::Error> for GeneratorError {
    fn from(err: serde_json::Error) -> Self {
        GeneratorError::Json(err)
    }
}

impl From<handlebars::TemplateError> for GeneratorError {
    fn from(err: handlebars::TemplateError) -> Self {
        GeneratorError::Template(err)
    }
}

impl From<handlebars::RenderError> for GeneratorError {
    fn from(err: handlebars::RenderError) -> Self {
        GeneratorError::Render(err)
    }
}

// Copied from schema_generator.rs for consistency
fn to_type_name(name: &str) -> String {
    let mut result = String::new();
    let mut capitalize_next = true;

    for c in name.chars() {
        if c == '_' || c == '-' { // Treat hyphen like underscore for capitalization
            capitalize_next = true;
        } else if capitalize_next {
            result.extend(c.to_uppercase());
            capitalize_next = false;
        } else {
            // Preserve existing uppercase chars for acronyms like P2P
            result.push(c);
        }
    }
    // Handle snake_case parts like `p2p_` -> `P2p`
    // Also explicitly replace hyphens remaining in the structure
    result.replace("P2p", "P2p").replace('-', "_")
}

fn main() -> Result<(), GeneratorError> {
    env_logger::init();
    info!("Starting API calls generation");

    let schema_path =
        std::env::var("SCHEMA_PATH").unwrap_or_else(|_| DEFAULT_SCHEMA_PATH.to_string());

    // Read and parse all schema files
    info!("Reading schema files from {}", schema_path);
    let endpoints = read_schema_files(&schema_path)?;

    // Generate API calls
    info!("Generating API calls");
    generate_api_calls(&endpoints)?;

    // Generate subscription calls
    info!("Generating subscription calls");
    generate_subscription_calls(&endpoints)?;

    info!("API call generation completed successfully");
    Ok(())
}

fn read_schema_files(schema_path: &str) -> Result<Vec<ApiEndpoint>, GeneratorError> {
    let mut endpoints = Vec::new();
    let path = Path::new(schema_path);

    for entry in fs::read_dir(path)? {
        let entry = entry?;
        let path = entry.path();

        if path.is_dir() {
            let name = path
                .file_name()
                .and_then(|n| n.to_str())
                .unwrap_or("")
                .to_string();

            // Skip if it's not a valid endpoint directory
            if name.is_empty() || name.starts_with('.') {
                continue;
            }

            let send_path = path.join("send.json");
            let receive_path = path.join("receive.json");

            if !send_path.exists() || !receive_path.exists() {
                debug!("Skipping {}: missing schema files", name);
                continue;
            }

            // Try reading and parsing the schema files
            match (read_json_file(&send_path), read_json_file(&receive_path)) {
                (Ok(send_schema), Ok(receive_schema)) => {
                    match parse_endpoint(&name, &send_schema, &receive_schema) {
                        Ok(endpoint) => {
                            debug!("Adding endpoint: {}", name);
                            endpoints.push(endpoint);
                        }
                        Err(e) => {
                            debug!("Failed to parse endpoint {}: {:?}", name, e);
                            // Continue with other endpoints
                            continue;
                        }
                    }
                }
                _ => {
                    debug!("Failed to read schema files for {}", name);
                    continue;
                }
            }
        }
    }

    Ok(endpoints)
}

fn read_json_file(path: &Path) -> Result<Value, GeneratorError> {
    let content = fs::read_to_string(path)?;
    Ok(serde_json::from_str(&content)?)
}

fn parse_endpoint(
    name: &str,
    send: &Value,
    _receive: &Value,
) -> Result<ApiEndpoint, GeneratorError> {
    let description = send["description"].as_str().unwrap_or("").to_string();

    let mut has_subscription = false;
    let mut subscribe_field_type: Option<String> = None;
    let mut subscribe_field_required = false;

    let required_fields: std::collections::HashSet<String> = send["required"]
        .as_array()
        .map(|arr| arr.iter().filter_map(|v| v.as_str().map(String::from)).collect())
        .unwrap_or_default();

    if let Some(props) = send["properties"].as_object() {
        if let Some(subscribe_prop) = props.get("subscribe") {
            has_subscription = true;
            subscribe_field_type = subscribe_prop["type"].as_str().map(String::from);
            if subscribe_field_type.is_none() {
                // Handle cases like type: ["integer", "null"] - extract non-null type
                if let Some(types) = subscribe_prop["type"].as_array() {
                    subscribe_field_type = types.iter()
                        .find(|t| t.as_str().map_or(false, |s| s != "null"))
                        .and_then(|t| t.as_str())
                        .map(String::from);
                }
            }
            subscribe_field_required = required_fields.contains("subscribe");
             debug!("Endpoint '{}': Found subscribe field. Type: {:?}, Required: {}", name, subscribe_field_type, subscribe_field_required);
        }
    }

    // Use the consistent to_type_name function
    let base_type_name = to_type_name(name);

    // --- BEGIN FIX: Handle known endpoint naming exceptions ---
    let (request_type, response_type) = match name {
        "p2p_advertiser_payment_methods" => (
            "P2pAdvertiserPaymentMethods".to_string(), // Request IS the enum
            "P2pAdvertiserPaymentMethods".to_string(), // Response IS ALSO the enum
        ),
        "set_financial_assessment" => (
            "SetFinancialAssessment".to_string(), // Request is just SetFinancialAssessment
            "SetFinancialAssessmentResponse".to_string(), // Response exists
        ),
         "crypto_estimations" => (
             "CryptoEstimationsRequest".to_string(), // Request exists
             "CryptoEstimations".to_string(), // Response is just CryptoEstimations
         ),
        // Default case: Assume standard Request/Response naming
        _ => (
            format!("{}Request", base_type_name),
            format!("{}Response", base_type_name),
        ),
    };
    // --- END FIX ---

    // --- BEGIN FIX: Handle special stream types ---
    let stream_type_base = match name {
        "buy" => "ProposalOpenContractResponse".to_string(),
        "p2p_order_create" | "p2p_order_list" => "P2pOrderInfoResponse".to_string(),
        "p2p_advertiser_create" => "P2pAdvertInfoResponse".to_string(),
        // --- BEGIN ADD: Handle p2p_advertiser_payment_methods stream --- 
        // If this endpoint *could* subscribe, its stream type would be the enum itself.
        "p2p_advertiser_payment_methods" => "P2pAdvertiserPaymentMethods".to_string(), 
        // --- END ADD ---
        // Default: Stream type is the same as the response type
        _ => response_type.clone(),
    };
    // --- END FIX ---

    let stream_type = if has_subscription {
        // Some(stream_type_base)
        Some(stream_type_base) // Use the potentially adjusted stream type
    } else {
        None
    };
    let feature_name = name.to_case(Case::Snake);

    Ok(ApiEndpoint {
        name: name.to_string(),
        description,
        has_subscription,
        request_type,
        response_type,
        stream_type,
        feature_name,
        subscribe_field_type,
        subscribe_field_required,
    })
}

fn generate_api_calls(endpoints: &[ApiEndpoint]) -> Result<(), GeneratorError> {
    let mut handlebars = Handlebars::new();
    handlebars.register_template_string("api_call", API_CALL_TEMPLATE)?;

    let mut output = String::from(HEADER_TEMPLATE);

    for endpoint in endpoints {
        let data = json!({
            "fn_name": endpoint.name.to_case(Case::Snake),
            "description": endpoint.description,
            "request_type": endpoint.request_type,
            "response_type": endpoint.response_type,
            "feature_name": endpoint.feature_name,
        });

        output.push_str(&handlebars.render("api_call", &data)?);
    }

    output.push_str("}
");
    fs::write(API_CALLS_FILE, output)?;

    Ok(())
}

fn generate_subscription_calls(endpoints: &[ApiEndpoint]) -> Result<(), GeneratorError> {
    let mut handlebars = Handlebars::new();
    // No need to escape for code gen
    handlebars.register_escape_fn(|s| -> String { s.to_string() });
    handlebars.register_template_string("subscription_call", SUBSCRIPTION_CALL_TEMPLATE)?;

    let mut output = String::from(HEADER_TEMPLATE);

    for endpoint in endpoints {
        if !endpoint.has_subscription {
            continue;
        }

        // Determine the correct subscribe assignment string based on generated type errors
        let subscribe_assignment = match endpoint.name.as_str() {
            "transaction" => {
                // Assumed non-optional i64(1) from previous checks
                 "request.subscribe = 1;".to_string()
            }
            "proposal" => {
                // Linter error showed expected String
                "request.subscribe = Some(\"1\".to_string());".to_string()
            }
            "website_status" | "balance" => {
                // Linter error showed expected Subscribe
                "request.subscribe = Some(deriv_api_schema::Subscribe::Value1);".to_string()
            }
             // Add other specific endpoints here if they expect Subscribe::Value1
             // "p2p_order_create" | "ticks" | ... => {
             //     "request.subscribe = Some(deriv_api_schema::Subscribe::Value1);".to_string()
             // }
            _ => {
                 // Default: Assuming most other subscribe fields are Option<i64>
                 // This covers p2p_order_create, ticks, ticks_history, etc. based on errors
                 "request.subscribe = Some(1);".to_string()
            }
        };

        let data = json!({
            "fn_name": endpoint.name.to_case(Case::Snake),
            "description": endpoint.description,
            "request_type": endpoint.request_type,
            "response_type": endpoint.response_type,
            "stream_type": endpoint.stream_type.as_ref().unwrap_or(&endpoint.response_type),
            "subscribe_assignment": subscribe_assignment // Add the assignment string to the data
        });

        // Render the single template with the correct data
        output.push_str(&handlebars.render("subscription_call", &data)?);
    }

    output.push_str("}
");
    fs::write(SUBSCRIPTION_CALLS_FILE, output)?;

    Ok(())
}
